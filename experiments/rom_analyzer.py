#!/usr/bin/env python3
"""
Standalone Range of Motion (ROM) Analyzer.

This script loads a 3D pose data JSON file (generated by the main application),
re-calculates all kinematic angles for every frame, determines the minimum and
maximum angle achieved (the range of motion), and visualizes the results
in a comprehensive dashboard plot.
"""
import json
import numpy as np
import matplotlib.pyplot as plt
import warnings

# --- KINEMATICS CONSTANTS & FUNCTIONS ---
# (Copied from kinematics.py for standalone use to avoid import issues)

warnings.filterwarnings(
    "ignore",
    message=".*autocast.*is deprecated.*",
    category=FutureWarning
)

ANGLE_KEYS = [
    "Neck (X-Axis Rotation)", "Neck (Y-Axis Rotation)", "Neck (Z-Axis Rotation)",
    "Torso-Neck (Vertical)", "Waist (X-Axis Rotation)", "Waist (Y-Axis Rotation)",
    "Waist (Z-Axis Rotation)", "R Shoulder (X-Axis Rotation)", "L Shoulder (X-Axis Rotation)",
    "R Shoulder (Y-Axis Rotation)", "L Shoulder (Y-Axis Rotation)", "R Shoulder (Z-Axis Rotation)",
    "L Shoulder (Z-Axis Rotation)", "R_Elbow (Bend)", "L_Elbow (Bend)",
    "R Hip (X-Axis Rotation)", "L Hip (X-Axis Rotation)", "R Hip (Y-Axis Rotation)",
    "L Hip (Y-Axis Rotation)", "R Hip (Z-Axis Rotation)", "L Hip (Z-Axis Rotation)",
    "R_Knee (Bend)", "L_Knee (Bend)",
]

def calculate_3d_angle(A, B, C):
    """Calculates the 3D angle at joint B defined by segments BA and BC."""
    v1 = A - B
    v2 = C - B
    denom = np.linalg.norm(v1) * np.linalg.norm(v2)
    if denom == 0: return 0.0
    cosv = np.clip(np.dot(v1, v2) / denom, -1.0, 1.0)
    return np.degrees(np.arccos(cosv))

def calculate_vertical_angle(Start, End):
    """Calculates the angle of a segment relative to the vertical axis (Y-up)."""
    seg = End - Start
    norm = np.linalg.norm(seg)
    if norm == 0: return 0.0
    cosv = np.clip(np.dot(seg, np.array([0.0, 1.0, 0.0])) / norm, -1.0, 1.0)
    return np.degrees(np.arccos(cosv))

def compute_rotation_matrix(proximal_vec, distal_vec, invert_z=False):
    """Computes a local coordinate system based on two segment vectors."""
    if np.linalg.norm(proximal_vec) < 1e-9 or np.linalg.norm(distal_vec) < 1e-9: return np.eye(3)
    p = proximal_vec / np.linalg.norm(proximal_vec)
    d = distal_vec / np.linalg.norm(distal_vec)
    y_axis = d
    x_temp = np.cross(p, d)
    if np.linalg.norm(x_temp) < 1e-6:
        if np.abs(np.dot(d, np.array([1.0, 0.0, 0.0]))) < 0.8:
            x_temp = np.cross(np.array([1.0, 0.0, 0.0]), d)
        else:
            x_temp = np.cross(np.cross(d, np.array([0.0, 0.0, 1.0])), d)
        if np.linalg.norm(x_temp) < 1e-6: return np.eye(3)
    z_axis = x_temp / np.linalg.norm(x_temp)
    if invert_z: z_axis *= -1
    x_axis = np.cross(y_axis, z_axis)
    x_axis /= np.linalg.norm(x_axis)
    return np.vstack([x_axis, y_axis, z_axis]).T

def rotation_matrix_to_euler_angles(R):
    """Converts a rotation matrix to ZYX Euler angles (in degrees)."""
    r_x = np.arcsin(np.clip(R[2, 0], -1.0, 1.0))
    cos_rx = np.cos(r_x)
    if abs(cos_rx) < 1e-6:
        r_y = 0.0
        r_z = np.arctan2(R[1, 1], R[0, 1])
    else:
        r_y = np.arctan2(R[1, 0] / cos_rx, R[0, 0] / cos_rx)
        r_z = np.arctan2(R[2, 1] / cos_rx, R[2, 2] / cos_rx)
    return np.degrees(r_x), np.degrees(r_y), np.degrees(r_z)

def calculate_anatomical_angles(kp):
    """Calculates all 3D Euler angles for ball-and-socket joints."""
    angles = {}
    if kp.shape[0] > 8:
        proximal_y = kp[7] - kp[0]; proximal_y /= np.linalg.norm(proximal_y)
        x_axis_ref = kp[4] - kp[1]; x_axis_ref /= np.linalg.norm(x_axis_ref)
        z_axis = np.cross(proximal_y, x_axis_ref); z_axis /= np.linalg.norm(z_axis)
        x_axis = np.cross(proximal_y, z_axis); x_axis /= np.linalg.norm(x_axis)
        R_local = np.vstack([x_axis, proximal_y, z_axis]).T
        distal_segment = kp[8] - kp[7]
        torso_y = distal_segment / np.linalg.norm(distal_segment)
        torso_x_temp = np.cross(x_axis_ref, torso_y)
        torso_z = torso_x_temp / np.linalg.norm(torso_x_temp)
        torso_x = np.cross(torso_y, torso_z); torso_x /= np.linalg.norm(torso_x)
        R_torso = np.vstack([torso_x, torso_y, torso_z]).T
        R_relative = R_torso @ R_local.T
        rx, ry, rz = rotation_matrix_to_euler_angles(R_relative)
        angles["Waist (X-Axis Rotation)"] = rx; angles["Waist (Y-Axis Rotation)"] = ry; angles["Waist (Z-Axis Rotation)"] = rz
    if kp.shape[0] > 9:
        Rm = compute_rotation_matrix(kp[7] - kp[8], kp[9] - kp[8])
        rx, ry, rz = rotation_matrix_to_euler_angles(Rm)
        angles["Neck (X-Axis Rotation)"] = rx; angles["Neck (Y-Axis Rotation)"] = ry; angles["Neck (Z-Axis Rotation)"] = rz
    proximal_torso_ref = kp[7] - kp[8]; proximal_torso_ref /= np.linalg.norm(proximal_torso_ref)
    if kp.shape[0] > 15:
        Rm = compute_rotation_matrix(proximal_torso_ref, kp[15] - kp[14], invert_z=False)
        rx, ry, rz = rotation_matrix_to_euler_angles(Rm)
        angles["R Shoulder (X-Axis Rotation)"] = rx; angles["R Shoulder (Y-Axis Rotation)"] = ry; angles["R Shoulder (Z-Axis Rotation)"] = rz
    if kp.shape[0] > 12:
        Rm = compute_rotation_matrix(proximal_torso_ref, kp[12] - kp[11], invert_z=True)
        rx, ry, rz = rotation_matrix_to_euler_angles(Rm)
        angles["L Shoulder (X-Axis Rotation)"] = rx; angles["L Shoulder (Y-Axis Rotation)"] = ry; angles["L Shoulder (Z-Axis Rotation)"] = rz
    if kp.shape[0] > 2:
        Rm = compute_rotation_matrix(kp[0] - kp[1], kp[2] - kp[1])
        rx, ry, rz = rotation_matrix_to_euler_angles(Rm)
        angles["R Hip (X-Axis Rotation)"] = rx; angles["R Hip (Y-Axis Rotation)"] = ry; angles["R Hip (Z-Axis Rotation)"] = rz
    if kp.shape[0] > 5:
        Rm = compute_rotation_matrix(kp[0] - kp[4], kp[5] - kp[4])
        rx, ry, rz = rotation_matrix_to_euler_angles(Rm)
        angles["L Hip (X-Axis Rotation)"] = rx; angles["L Hip (Y-Axis Rotation)"] = ry; angles["L Hip (Z-Axis Rotation)"] = rz
    return angles

def process_all_angles(kp):
    """Calculates all 23 angles from a single keypoint array."""
    all_angles = {}
    checks = [(1,2,3,"R_Knee"), (4,5,6,"L_Knee"), (14,15,16,"R_Elbow"), (11,12,13,"L_Elbow")]
    for A,B,C,name in checks:
        if C < kp.shape[0]: all_angles[f"{name} (Bend)"] = calculate_3d_angle(kp[A], kp[B], kp[C])
    if 8 < kp.shape[0]: all_angles["Torso-Neck (Vertical)"] = calculate_vertical_angle(kp[7], kp[8])
    all_angles.update(calculate_anatomical_angles(kp))
    return all_angles
# --- END OF KINEMATICS FUNCTIONS ---

def analyze_rom_from_file(file_path):
    """
    Loads a JSON file, calculates all angles for each frame, and
    returns a dictionary with the min and max values for each angle.
    """
    print(f"Loading and analyzing data from '{file_path}'...")
    try:
        with open(file_path, 'r') as f:
            data = json.load(f)
    except (FileNotFoundError, json.JSONDecodeError) as e:
        print(f"Error: Could not read or parse the file. {e}")
        return None

    # Initialize a dictionary to store lists of angle values over time
    angle_data = {key: [] for key in ANGLE_KEYS}

    # Process every frame in the loaded data
    for frame_info in data:
        predictions = frame_info.get('predictions', [])
        if not predictions:
            continue # Skip frames with no detected people

        # Assuming the first person's keypoints
        keypoints_list = predictions[0].get('keypoints')
        if keypoints_list:
            kp = np.array(keypoints_list)
            
            # Flip Y axis to match visualization convention
            kp[:, 1] = -kp[:, 1]
            
            # Calculate all angles for the current frame
            current_angles = process_all_angles(kp)
            
            # Append each angle to its corresponding list
            for key, value in current_angles.items():
                if key in angle_data:
                    angle_data[key].append(value)

    # Calculate min and max for each angle
    rom_ranges = {}
    for key, values in angle_data.items():
        if values:
            rom_ranges[key] = (min(values), max(values))
        else:
            rom_ranges[key] = (0, 0) # Default if no data was found for an angle

    print("Analysis complete.")
    return rom_ranges

def plot_rom_dashboard(rom_ranges, file_path):
    """
    Generates and displays a horizontal bar chart visualizing the range of motion.
    """
    labels = list(rom_ranges.keys())
    min_vals = [val[0] for val in rom_ranges.values()]
    max_vals = [val[1] for val in rom_ranges.values()]
    
    # The width of each bar is the difference between max and min
    bar_widths = [mx - mn for mn, mx in zip(min_vals, max_vals)]
    
    # Define colors for different body parts for better readability
    colors = []
    for key in labels:
        if 'Knee' in key or 'Hip' in key: colors.append('#2ecc71') # Green
        elif 'Shoulder' in key or 'Elbow' in key: colors.append('#3498db') # Blue
        elif 'Neck' in key or 'Torso' in key or 'Waist' in key: colors.append('#9b59b6') # Purple
        else: colors.append('#333333')

    fig, ax = plt.subplots(figsize=(14, 10))

    # Create the horizontal bars. The `left` parameter sets the starting point.
    bars = ax.barh(labels, bar_widths, left=min_vals, color=colors, edgecolor='black', alpha=0.8)

    # Add a vertical line at 0 for reference
    ax.axvline(0, color='black', linestyle='--', linewidth=0.8)

    # Set titles and labels
    ax.set_title(f'Range of Motion Analysis\n(Source: {file_path})', fontsize=16, pad=20)
    ax.set_xlabel('Angle (Degrees)', fontsize=12)
    ax.set_ylabel('Kinematic Angle', fontsize=12)
    
    # Invert the y-axis to match the order in ANGLE_KEYS
    ax.invert_yaxis()
    
    # Add grid for better readability
    ax.grid(axis='x', linestyle=':', color='gray')
    ax.set_axisbelow(True)

    # Add text labels for min and max values on each bar
    for i, bar in enumerate(bars):
        min_val = min_vals[i]
        max_val = max_vals[i]
        
        # Min label
        ax.text(min_val - 2, bar.get_y() + bar.get_height()/2., f'{min_val:.1f}°', 
                ha='right', va='center', color='darkred', fontsize=8)
        
        # Max label
        ax.text(max_val + 2, bar.get_y() + bar.get_height()/2., f'{max_val:.1f}°', 
                ha='left', va='center', color='darkgreen', fontsize=8)

    # Adjust layout and display the plot
    plt.tight_layout()
    print("Displaying dashboard. Close the plot window to exit.")
    plt.show()


if __name__ == "__main__":
    # ---------------------------------------------------------------- #
    # === EDIT THIS LINE to the name of the file you want to analyze! ===
    INPUT_JSON_FILE = "/home/popoy/projects/proj_1/videos/Jsons/webcam_3d_pose_recording.json"
    # ---------------------------------------------------------------- #
    
    # 1. Analyze the data from the file
    rom_data = analyze_rom_from_file(INPUT_JSON_FILE)
    
    # 2. If analysis was successful, create the plot
    if rom_data:
        plot_rom_dashboard(rom_data, INPUT_JSON_FILE)